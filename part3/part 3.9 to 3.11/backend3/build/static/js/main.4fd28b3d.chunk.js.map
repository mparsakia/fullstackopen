{"version":3,"sources":["services/personsDB.js","index.jsx"],"names":["baseUrl","axios","get","then","response","data","newObject","post","id","delete","put","Filter","props","value","filter","onChange","handleFilter","Display","entry","map","ent","key","dfx","deletefx","AddPerson","className","onSubmit","addPerson","newName","handleNameChange","newNumber","handleNumberChange","type","PhoneBookEntry","name","number","onClick","Notification","message","style","App","useState","persons","setPersons","setNewName","setNewNumber","setFilter","notifmsg","setNotification","notifcss","setCss","useEffect","personService","notifHandler","peopleDisplay","toLowerCase","includes","event","target","preventDefault","find","x","window","confirm","rtnobj","p","setTimeout","returnedObj","concat","deleteme","element","undefined","catch","error","alert","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.4fd28b3d.chunk.js","sourcesContent":["import axios from 'axios'\r\nconst baseUrl = './api/persons'\r\n\r\nconst getAll = () => {\r\n  const request = axios.get(baseUrl)\r\n  return request.then(response => response.data)\r\n}\r\n\r\nconst create = newObject => {\r\n  const request = axios.post(baseUrl, newObject)\r\n  return request.then(response => response.data)\r\n}\r\n\r\nconst update = (id, newObject) => {\r\n  const request = axios.put(`${baseUrl}/${id}`, newObject)\r\n  return request.then(response => response.data)\r\n}\r\n\r\nconst deleteID = (id, newObject) => {\r\n  const request = axios.delete(`${baseUrl}/${id}`, newObject);\r\n  return request.then(response => response.data)\r\n}\r\n\r\nexport default {\r\n  getAll: getAll,\r\n  create: create,\r\n  deleteID: deleteID,\r\n  update: update\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The App component has become somewhat bloated after adding the\r\n * code for communicating with the backend server. In the spirit of the\r\n * single responsibility principle, we deem it wise to extract this\r\n * communication into its own module.\r\n *\r\n *\r\n * The module returns an object that has three functions\r\n * (getAll, create, and update) as its properties that deal with notes.\r\n * The functions directly return the promises returned by the axios methods.\r\n * The App component uses import to get access to the module:\r\n *\r\n * The functions of the module can be used directly with the imported variable noteService as follows:\r\n *  https://fullstackopen.com/en/part2/altering_data_in_server (scroll down to Extracting comms...)\r\n *\r\n * In practice, the error handler for rejected promises is defined like this:\r\n\r\n    axios\r\n      .get('http://example.com/probably_will_fail')\r\n      .then(response => {\r\n        console.log('success!')\r\n      }).catch(error => {\r\n        console.log('fail')\r\n      })\r\n\r\n   If the request fails, the event handler registered with the catch method gets called.\r\n   When our application makes an HTTP request, we are in fact creating a promise chain:\r\n\r\n\r\n    const toggleImportanceOf = id => {\r\n    const note = notes.find(n => n.id === id)\r\n    const changedNote = { ...note, important: !note.important }\r\n\r\n    noteService\r\n      .update(id, changedNote).then(returnedNote => {\r\n        setNotes(notes.map(note => note.id !== id ? note : returnedNote))\r\n      })\r\n      .catch(error => {\r\n        alert(\r\n          `the note '${note.content}' was already deleted from server`\r\n        )\r\n        setNotes(notes.filter(n => n.id !== id))\r\n      })\r\n    }\r\n\r\n    Removing an already deleted note from the application's state is done with the array filter method,\r\n    which returns a new array comprising only of the items from the list for which the function that\r\n    was passed as a parameter returns true for:    notes.filter(n => n.id !== id)\r\n *\r\n */","// FullStackOpen Phonebook - through v2.19\n\nimport React, { useState, useEffect } from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport personService from './services/personsDB'\n\nconst Filter = (props) => (\n  <p>\n    Filter by Name: <input value={props.filter} onChange={props.handleFilter} />\n  </p>\n)\n\nconst Display = (props) => (\n  <div>\n    {props.entry.map(ent => <PhoneBookEntry key={ent.id} entry={ent} dfx={props.deletefx} />)}\n  </div>\n)\n\nconst AddPerson = (props) => (\n  <div className=\"add\">\n    <h2>Add or update a person:</h2>\n    <form onSubmit={props.addPerson}>\n      <div>name: <input value={props.newName} onChange={props.handleNameChange} /> </div>\n      <div>number: <input value={props.newNumber} onChange={props.handleNumberChange} /></div>\n      <div><button type=\"submit\">add to phonebook</button></div>\n    </form>\n  </div>\n)\n\nconst PhoneBookEntry = (props) => {\n  return (\n    <div>\n      <li>{props.entry.name}</li>\n      <li>{props.entry.number}</li>\n      <button onClick={() => props.dfx(props.entry.id)}>Click to Delete</button>\n      <small> json db id: {props.entry.id}</small>\n    </div>\n  )\n}\n\nconst Notification = (props) => {\n  if (props.message === null) {\n    return null\n  }\n  return (\n    <div className={props.style}>\n      {props.message}\n    </div>\n  )\n}\n\n\n\nconst App = (props) => {\n  const [persons, setPersons] = useState([])  // this time populated with useEffect and axios\n  const [newName, setNewName] = useState(\"Enter a name\")\n  const [newNumber, setNewNumber] = useState(\"Enter a Number\")\n  const [filter, setFilter] = useState(\"\")\n  const [notifmsg, setNotification] = useState(\"\");\n  const [notifcss, setCss] = useState(\"\")\n\n\n  // obtain values from db with axios to persons/setPersons state & extracted w/ personsDB\n  useEffect(() => {\n    personService\n      .getAll()\n      .then(response => {\n        setPersons(response)\n      })\n  }, [])\n\n\n  const handleName = (event) => {\n    setNewName(event.target.value);\n  }\n\n  const handleNumber = (event) => {\n    setNewNumber(event.target.value);\n  }\n\n  const handleFilter = (event) => {\n    setFilter(event.target.value)\n  }\n\n  const notifHandler = (message, style) => {\n    setNotification(message);\n    setCss(style);\n  }\n\n\n  const addPerson = (event) => {\n    event.preventDefault()  // form submissions default reload the page so we need to prevent this\n    if (persons.find(x => x.name === newName)) {\n      if (window.confirm(`${newName} is already added to phonebook, want to update their phone number?`)) {\n        const entry = persons.find(x => x.name === newName);\n        entry.number = newNumber;\n        personService.update(entry.id, entry).then(rtnobj => {\n          setPersons(persons.filter(p => p.id))\n        });\n        notifHandler(`${newName} has been updated.`, \"success\");\n        setTimeout(() => {\n          notifHandler(null, null)\n        }, 5000)\n      }\n    } else {\n      const personObj = { name: newName, number: newNumber };\n      // Using axios, allow us to \"save\" data in jsondb & update the view, extracted w personsDB\n      personService.create(personObj).then(returnedObj => { setPersons(persons.concat(returnedObj)) });\n      notifHandler(`${newName} has been created.`, \"success\");\n      setTimeout(() => {\n        notifHandler(null, null)\n      }, 5000)\n      setNewName('');\n      setNewNumber('');\n    }\n  }\n  // filter what will be passed into Display JSX\n  const peopleDisplay = persons.filter(persons => persons.name.toLowerCase().includes(filter.toLowerCase()))\n\n  const deleteById = (id) => {\n    const deleteme = persons.find(element => element.id === id);\n    if (deleteme === undefined) {\n      alert(\"Error assigning deleteme, it is undefined. Returning now.\");\n      return;\n    } else {\n      if (window.confirm(\"Are you sure you wish to delete: \" + deleteme.name)) {\n        personService.deleteID(id, deleteme)\n          .then(rtnobj => {\n            setPersons(persons.filter(p => p.id !== id))\n            notifHandler(`${deleteme.name} has been deleted!`, \"error\");\n            setTimeout(() => {\n              notifHandler(null, null)\n            }, 5000);\n          })\n          .catch(error => {\n            if (error.response) {\n              notifHandler(\"Recieved error response, i.e. 404.\", \"error\");\n              setTimeout(() => {\n                notifHandler(null, null)\n              }, 5000);\n              setPersons(persons.filter(p => p.id !== id))\n            } else {\n              alert(\"Unhandled error here...\");\n              setPersons(persons.filter(p => p.id !== id))\n            }\n          })\n      }\n    }\n  }\n\n\n  return (\n    <div className=\"phonebook\">\n      <h1>Phonebook</h1>\n\n      <Notification message={notifmsg} style={notifcss} />\n\n      <Filter filter={filter} handleFilter={handleFilter} />\n\n      <AddPerson\n        addPerson={addPerson}\n        newName={newName}\n        newNumber={newNumber}\n        handleNameChange={handleName}\n        handleNumberChange={handleNumber}\n      />\n\n      <br></br>\n\n      <Display entry={peopleDisplay} deletefx={deleteById} />\n\n    </div>\n  )\n}\n\n\nReactDOM.render(<App/>, document.getElementById('root'))\n\n\n\n\n\n\n\n\n"],"sourceRoot":""}